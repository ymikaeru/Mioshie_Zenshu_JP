<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="utf-8">
    <title>Â≤°Áî∞Ëá™Ë¶≥Â∏´„ÅÆË´ñÊñáÈõÜ</title>
    <style>
        body {
            font-family: "Hiragino Mincho ProN", "Yu Mincho", serif;
            background-color: #e9feda;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 90vh;
            /* Centered vertically */
        }

        h1 {
            font-family: "HGÊ≠£Ê•∑Êõ∏‰Ωì-PRO", "HGPÊ≠£Ê•∑Êõ∏‰Ωì", "Hiragino Mincho ProN", serif;
            font-size: 28px;
            color: #2c3e50;
            margin-bottom: 2rem;
            letter-spacing: 0.2em;
            text-align: center;
        }

        #yamatomizu-widget {
            background: #ffffff;
            padding: 40px;
            border-radius: 2px;
            /* Slight roundness for Nordic feel but keeping it clean */
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.05);
            /* Soft shadow */
            max-width: 600px;
            width: 90%;
            text-align: center;
            position: relative;
            box-sizing: border-box;
            border: 1px solid #e0e0e0;
        }

        .poem-container {
            min-height: 200px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            margin-bottom: 30px;
            text-align: left;
            /* Better for long text */
        }

        .poem-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .poem-title {
            font-size: 14px;
            color: #7f8c8d;
            margin-bottom: 10px;
            font-family: sans-serif;
        }

        .poem-text {
            font-size: 24px;
            line-height: 1.6;
            color: #2c3e50;
            margin-bottom: 5px;
            font-weight: 500;
            font-family: "HGÊ≠£Ê•∑Êõ∏‰Ωì-PRO", "HGPÊ≠£Ê•∑Êõ∏‰Ωì", serif;
        }

        .poem-reading {
            font-size: 13px;
            color: #95a5a6;
            margin-bottom: 25px;
        }

        .poem-section {
            margin-bottom: 15px;
            font-size: 15px;
            line-height: 1.6;
            border-bottom: 1px solid #f0f0f0;
            padding-bottom: 10px;
        }

        .poem-section:last-child {
            border-bottom: none;
        }

        .section-label {
            font-weight: bold;
            color: #5d737e;
            display: block;
            margin-bottom: 4px;
            font-size: 13px;
            font-family: sans-serif;
        }

        /* Scrollable content if it gets too tall */
        .poem-content-scroll {
            max-height: 500px;
            overflow-y: auto;
            padding-right: 10px;
            /* scrollbar styling */
            scrollbar-width: thin;
            scrollbar-color: #bdc3c7 #f5f5f5;
        }

        .poem-content-scroll::-webkit-scrollbar {
            width: 6px;
        }

        .poem-content-scroll::-webkit-scrollbar-track {
            background: #f5f5f5;
        }

        .poem-content-scroll::-webkit-scrollbar-thumb {
            background-color: #bdc3c7;
            border-radius: 3px;
        }
    </style>
</head>

<body>

    <h1>Â≤° Áî∞ Ëá™ Ë¶≥ Â∏´ „ÅÆ Ë´ñ Êñá ÈõÜ</h1>

    <div id="yamatomizu-widget">
        <div class="nav-buttons">
            <button class="nav-btn" id="prev-btn" onclick="changePoem(-1)">&#10094;</button>
            <button class="nav-btn" id="next-btn" onclick="changePoem(1)">&#10095;</button>
        </div>

        <div class="poem-container">
            <div id="poem-display" class="poem-content-scroll">
                <!-- Content will be loaded here -->
                <p style="color: #999; text-align: center;">Loading poems...</p>
            </div>
        </div>

        <a href="yamatomizu.html" target="main" class="action-btn">
            Â±±„Å®Ê∞¥ AIËß£Ë™¨„Å∏
        </a>
    </div>

    <script>
        let poems = [];
        let currentIndex = 0;

        async function loadPoems() {
            try {
                const response = await fetch('yamatomizu.json');
                const data = await response.json();

                poems = [];

                function traverse(node) {
                    if (node.level === 3 && node.content) {
                        let poemData = {};
                        let hasPoem = false;

                        node.content.forEach(p => {
                            if (!p.text) return;

                            if (p.text.includes('Âæ°Ê≠å:')) {
                                poemData.original = p.text.replace('Âæ°Ê≠å:', '').trim();
                                hasPoem = true;
                            } else if (p.text.includes('Ë™≠„Åø:')) {
                                poemData.reading = p.text.replace('Ë™≠„Åø:', '').trim();
                            } else if (p.text.includes('Áèæ‰ª£Ë™ûÊÑèË®≥:')) {
                                // Sometimes content is in the next object or same text line?
                                // Based on previous view, it's usually "Áèæ‰ª£Ë™ûÊÑèË®≥:" then text in next paragraph or same?
                                // Let's simplify: regex or split.
                                // The JSON view showed simple strings.
                                // Actually, one sample showed: "text": "Áèæ‰ª£Ë™ûÊÑèË®≥:" then next object "text": "„Äå...„Äç"
                                // But looking at the logic, I need to capture the text *following* the label if it's separate, 
                                // or the text *in* the same string.
                                // Let's just store all texts and process or map them.
                                // Actually, let's look for the specific prefixes.
                                // Wait, the JSON view showed:
                                // { "text": "Áèæ‰ª£Ë™ûÊÑèË®≥:" }, { "text": "„Äå...„Äç" } 
                                // So I need to be careful.
                            }
                        });

                        // Let's refine parsing to be more robust by just grabbing all text arrays
                        if (hasPoem) {
                            // Re-parse content to get all fields accurately
                            let currentLabel = null;

                            node.content.forEach(p => {
                                let t = p.text || "";
                                if (t.includes('Âæ°Ê≠å:')) {
                                    poemData.original = t.replace('Âæ°Ê≠å:', '').trim();
                                } else if (t.includes('Ë™≠„Åø:')) {
                                    poemData.reading = t.replace('Ë™≠„Åø:', '').trim();
                                } else if (t.includes('Áèæ‰ª£Ë™ûÊÑèË®≥:')) {
                                    currentLabel = 'meaning';
                                    poemData.meaning = t.replace('Áèæ‰ª£Ë™ûÊÑèË®≥:', '').trim();
                                } else if (t.includes('üçÉ Â≠£Ë™û„Å®È¢®Áâ©:')) {
                                    currentLabel = 'season';
                                    poemData.season = t.replace('üçÉ Â≠£Ë™û„Å®È¢®Áâ©:', '').trim();
                                } else if (t.includes('üéµ Ë®ÄÈúä„Å®Ë™ø„Åπ:')) {
                                    currentLabel = 'melody';
                                    poemData.melody = t.replace('üéµ Ë®ÄÈúä„Å®Ë™ø„Åπ:', '').trim();
                                } else if (t.includes('üèîÔ∏è Ê∑±Â±§„ÅÆÊïôË®ì:')) {
                                    currentLabel = 'lesson';
                                    poemData.lesson = t.replace('üèîÔ∏è Ê∑±Â±§„ÅÆÊïôË®ì:', '').trim();
                                } else {
                                    // Append to current label if it exists (for multi-paragraph content)
                                    // Specifically for 'meaning' which was split in the JSON sample
                                    if (currentLabel && t.trim().length > 0) {
                                        poemData[currentLabel] = (poemData[currentLabel] || "") + " " + t.trim();
                                    }
                                }
                            });

                            poemData.id = node.title;
                            poems.push(poemData);
                        }
                    }
                }

                if (data.data && Array.isArray(data.data)) {
                    data.data.forEach(item => traverse(item));
                }

                if (poems.length > 0) {
                    currentIndex = Math.floor(Math.random() * poems.length);
                    renderPoem(currentIndex);
                } else {
                    document.getElementById('poem-display').innerHTML = '<p>No poems found.</p>';
                }

            } catch (error) {
                console.error('Error loading poems:', error);
                document.getElementById('poem-display').innerHTML = '<p>Error loading poems.</p>';
            }
        }

        function renderPoem(index) {
            const container = document.getElementById('poem-display');
            const poem = poems[index];

            container.classList.remove('fade-in');
            void container.offsetWidth;
            container.classList.add('fade-in');

            let html = `
                <div class="poem-header">
                    <div class="poem-title">No. ${poem.id}</div>
                    <div class="poem-text">${poem.original}</div>
                    <div class="poem-reading">${poem.reading || ''}</div>
                </div>
            `;

            container.innerHTML = html;
        }

        function changePoem(direction) {
            if (poems.length === 0) return;

            currentIndex += direction;

            if (currentIndex < 0) {
                currentIndex = poems.length - 1;
            } else if (currentIndex >= poems.length) {
                currentIndex = 0;
            }

            renderPoem(currentIndex);
        }

        // Initialize
        loadPoems();
    </script>
</body>

</html>